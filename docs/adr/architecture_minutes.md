# 設備劣化検知プロジェクト — アーキテクチャ設計 議事録

## プロジェクト概要

設備の劣化や異常を事前に検知し、ユーザーが兆候を確認できるようにするシステムを構築する。
設備の作業時間の伸びと劣化に相関があるという仮説に基づく。

---

## 開発ロードマップ（3ステップ）

| Step | 内容 |
|------|------|
| Step 1 | 分類別に二次元プロット（n回, t秒）を可視化し、ユーザーが視認できるようにする |
| Step 2 | Isolation Forestの評価指数をユーザーがデータをもとに定義する |
| Step 3 | 継続的に流れてくるデータが正常かどうかを監視し続ける |

---

## 確定事項

### ドメインモデル

```
作業記録 {
  分類:        [大分類, 中分類, ...（ツリー構造、可変深度）]
  作業時間:     t（秒）
  タイムスタンプ: 記録日時
}
```

### 分類構造

- 親子関係を持つツリー構造とする。
- 現時点では大分類（作業プロセス名）・中分類（設備名称）の2階層。小分類を追加する可能性がある。
- 最初から可変深度の階層として設計し、後から分類軸を足す際のスキーマ変更コストを回避する。

### 「回数n」の扱い

- ドメインモデルの属性としては持たない。
- nはタイムスタンプから導出可能な値であり、分析層が分類×時系列ソートで算出する。
- 採用理由：
  1. タイムスタンプの方が情報量が多い（nからタイムスタンプは復元不可）。
  2. パイプラインの差分取得カーソルとして自然に機能する（「このdatetime以降のデータをリクエスト」）。
  3. 時間的ギャップ（長期間の停止→再稼働等）が可視化でき、劣化モデルの精度に寄与する。

### データ取り込み層の設計方針

- データの流入経路は抽象化する。RDB、JSON、CSV等、どのデータソースからでも注入可能にする。
- 取り込み層は外部データソースとの接点に「アダプター」を置き、内部に渡す時点では統一されたドメインモデルに変換済みとする。
- パイプライン自体の設計は本プロジェクトのスコープ外。

---

## コンポーネント構成

| 層 | 責務 |
|----|------|
| 1. データ取り込み層（Ingestion） | 外部データソースとの接点。アダプターによりドメインモデルへ変換 |
| 2. データ蓄積・管理層（Store） | 正規化データの永続化と検索。分類階層の管理 |
| 3. 分析層（Analysis） | トレンド分析、異常検知、異常判定。結果は結果ストアに保存 |
| 4. 結果ストア（Result Store） | 分析結果の永続化と提供。分析層が書き込み、表示層が読み取る |
| 5. 表示層（Presentation） | プロット可視化、監視ダッシュボード |

### 依存関係

```
取り込み層 → Store層 ← 表示層
                ↑
             分析層 → 結果ストア ← 表示層
```

- 各層の依存方向は一方向であり、循環はない。
- 表示層はStore層と結果ストアの2箇所から読み取るが、Store層だけでも基本的なデータ可視化（Step 1のプロット）は成立する。
- 分析層は表示の前提条件ではなく、分析結果を付加する存在。分析層が停止していても可視化機能は維持される。

---

## 層間インターフェース定義

### 境界①: 取り込み層 → Store層

```
投入（バッチ）:
  入力:  作業記録のリスト
  振る舞い: 分類×タイムスタンプが既存と一致するものは上書き、
           それ以外は新規追加
  一意性キー: 分類 × タイムスタンプ
```

### 境界②: Store層 → 分析層 / 表示層（共通インターフェース）

```
データ取得:
  入力:  分類キー, [開始日時], [終了日時]
  出力:  作業記録のリスト
  備考:  期間省略時は全期間。
         トレンド分析（全期間）、ベースライン構築（期間指定）、
         プロット表示、Step 3差分取得（開始日時指定）の全てを
         同一インターフェースで賄う。

分類ツリー取得:
  入力:  なし（or 起点ノード指定）
  出力:  ツリー構造
```

### 境界③: 結果ストア → 表示層

```
分析結果取得:
  入力:  分類キー
  出力:  {
    トレンド:   { 傾き, 切片, 警告有無 }
    異常判定:   [{ タイムスタンプ, 正常/異常 }]
  }
```

表示層はStore層の生データと結果ストアの分析結果を組み合わせて描画する。結合は表示層の責務。

---

## 分析層の内部構造

### 分析の責務分離

Isolation Forestとトレンド分析は補完関係にあり、それぞれ異なる種類の劣化兆候を検知する。

| 検知対象 | アプローチ | 説明 |
|---|---|---|
| 緩やかな経年劣化 | トレンド分析（回帰） | 傾きの大きさで劣化傾向を把握 |
| 突発的な異常値 | Isolation Forest | 分布からの逸脱を検出 |

Isolation Forestは点単位の孤立度を評価するため、時系列の順序関係は見ない。緩やかに上昇するデータは各点が分布の中で極端に孤立しないため検出されにくい。逆に、トレンド分析は全体傾向を見るため突発的な外れ値の検出には向かない。両方を併用する。

### ユーザー関与による分離

| 責務 | 対象期間 | 定義者 |
|---|---|---|
| トレンド分析 | 全期間 | システム（固定ロジック） |
| 異常検知（Isolation Forest） | ベースライン期間 | ユーザー（GUI操作） |
| 異常判定（Step 3） | 新規データ | システム（学習済みモデル適用） |

- トレンド分析はユーザーが関与しない。劣化傾向は客観的事実であり、システム側で固定ロジックとして定義する。
- Isolation Forestのモデル定義はユーザーがGUIで操作して定義する。

### モデル定義（末端ノードごとに保持）

ユーザーがStep 2でGUI上で定義するもの：

1. **ベースライン期間** — プロット上で範囲選択。Isolation Forestが「正常」とみなすデータの期間
2. **ベースライン内の除外点** — プロット上で個別選択。外乱等で伸びたデータを正常データセットから除外
3. **感度** — UIではスライダーで操作。内部的にはIsolation Forestのcontaminationパラメータへマッピングされる。スライダーを動かすとプロット上の異常判定結果がリアルタイムに変化し、ユーザーはcontaminationの数値を意識せずに適切な感度を探索できる

その他のIsolation Forestパラメータ（n_estimators, max_samples, max_features, random_state）はユーザーに公開しない。システム側で固定値を定義する。

### モデル定義の粒度

- 末端ノード（最も細かい分類）ごとに1つのモデル定義を持つ（パターンA）。
- 上位分類からの継承や一括適用の仕組みは設けない。
- 採用理由：構造がシンプルであり、モデル定義と分類ノードが1対1で常に明確。

---

## Step 3: 継続監視の設計

### 判定トリガー

- スケジュールによる定期実行とする。
- 開発フェーズでは手動トリガーも可能にする。手動トリガーを最終プロダクトに残すかどうかは後日判断。

### アラート

- ダッシュボードでの確認のみとする。プッシュ通知（メール等）は設けない。

### 判定フロー

1. 定期実行（またはまた手動トリガー）で分析層が起動
2. 分析層がStore層から前回判定以降の新規データを取得（境界②の開始日時指定）
3. 学習済みIsolation Forestモデルで各データポイントを正常/異常判定
4. トレンド分析を全期間データで再計算
5. 判定結果を結果ストアに保存
6. 表示層（ダッシュボード）が結果ストアから読み取り表示

---

*最終更新: 2026-02-09*
