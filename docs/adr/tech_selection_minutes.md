# 設備劣化検知プロジェクト — 技術選定 議事録

## 前提条件

### 非機能要件

| 項目 | 現状 | 将来 |
|------|------|------|
| データ量 | 小規模 | 拡張の可能性あり |
| ユーザー数 | 少数 | 拡張の可能性あり |
| 可用性 | 重視しない | 最終形態でも重視しない |

### 制約

- デプロイ先はオンプレ
- コンテナで管理する
- チームの技術スタックや学習容易性は考慮しない

### アーキテクチャ上の前提

- 層間インターフェースが確定済みのため、各層の裏側の技術は独立して差し替え可能
- 将来のマイグレーションを想定し、実装パイプラインは抽象化する

---

## 選定順序

依存の下流から固める方針：

1. Store層（DB） ✅ 確定
2. 結果ストア ✅ 確定
3. 分析層 ✅ 確定
4. 取り込み層 ✅ 確定
5. 表示層 ✅ 確定
6. コンテナ構成 ✅ 確定

---

## 確定事項

### 1. Store層: SQLite

**候補の比較：**

| | 学習コスト | バンドルサイズ | パフォーマンス（本ユースケース） | マイグレーション容易性 |
|---|---|---|---|---|
| PostgreSQL | 低 | 中 | 中 | 高 |
| MySQL/MariaDB | 低 | 中 | 中 | 高 |
| **SQLite** | **極低** | **極小** | **低〜中** | **中** |
| InfluxDB | 高 | 大 | 高 | 低 |
| TimescaleDB | 低〜中 | 中〜大 | 高 | 高 |
| QuestDB | 中 | 中 | 高 | 低〜中 |
| MongoDB | 中 | 大 | 中 | 低 |
| Parquet+DuckDB | 低〜中 | 極小 | 分析クエリ高、書き込み不向き | 中 |

**消去の過程：**

- MongoDB — 本ユースケースで選ぶ理由がない。パフォーマンスの優位性なし、マイグレーションコスト高、バンドル大
- InfluxDB — 独自クエリ言語による学習コスト高、マイグレーション容易性低。現データ量では時系列特化の恩恵を受けない
- QuestDB — 同様にエコシステムが小さく優先度低
- 残った4候補（PostgreSQL、SQLite、TimescaleDB、Parquet+DuckDB）からSQLiteを採用

**採用理由：**

- バンドルサイズ最小、学習コスト最低
- コンテナ上でファイル一つで完結
- 現時点の小規模なデータ量に対して過剰な選択をしない
- Store層のインターフェースが抽象化済みのため、将来PostgreSQL等への移行はインターフェース内側の変更で済む

### 2. 結果ストア: SQLite（Store層とは別ファイル）

- Store層と同一SQLiteインスタンスには同居させない
- 物理的にファイルを分離することで、責務の分離が明確になる
- 分析層だけ再構築したいときに結果ストアだけ消せる
- 分離のコストはほぼゼロ

### 3. 分析層: Python + scikit-learn

- Isolation Forestと線形回帰を使う以上、Python + scikit-learnが自然な選択
- 他の言語で同等の実装は車輪の再発明になる
- 必要ライブラリ：
  - scikit-learn（Isolation Forest、線形回帰）
  - numpy / pandas（データ操作）

### 4. 取り込み層: Python + FastAPI

**結合方式の検討：**

| 方式 | 概要 | 評価 |
|------|------|------|
| A案: 全層API（HTTP/REST）で疎結合 | マイクロサービス的構成 | 小規模にはオーバーヘッド大。HTTPサーバー常駐、死活管理が増える |
| B案: 共有ライブラリで直接結合 | 同一プロセス内で関数呼び出し | シンプルだが、アダプターがコンテナの制約を受ける |
| C案: CLIインターフェース | コマンドラインツールとして独立 | B案と同様のコンテナ制約 |

**問題点：** B案・C案では取り込み層（アダプター）がコンテナ内に配置される。外部データソースへのアクセスがコンテナの制約を受け、新しいデータソース追加のたびにコンテナ構成を変更する必要がある。これはアダプターパターンによる抽象化の設計意図と矛盾する。

**採用方式: 混合（取り込み層はAPI、コンテナ内は直接結合、表示層はAPI経由）**

表示層をフロントエンド分離としたため、Store層と結果ストアへのアクセスにもAPIが必要。取り込みAPIとデータ提供APIは同一のFastAPIアプリにまとめる。

```
[コンテナ外]                  [コンテナ内]

  RDB ─→ アダプター ─→ 取り込みAPI ──→ Store層(SQLite)
  CSV ─→ アダプター ─┘                    ↑    │
  JSON ─→ アダプター ─┘                 分析層  │ データ提供API
                                  │        │
                                  ↓        ↓
                              結果ストア ──→ データ提供API
                                              │
                                              ↓
                                     [フロントエンド]
```

**FastAPIの採用理由：**

- 薄いエンドポイントが必要なユースケースに対して軽量
- Pythonで統一でき、バリデーションが標準で付く
- 型定義とバリデーションの自動化の点でFlaskより本ユースケースに適合
- 取り込みAPI + データ提供APIを同一アプリにまとめられる

**Store層のインターフェースは抽象クラス（ABC等）として定義する。** SQLiteを直接触るコードが分析層に漏れると後からの分離が困難になるため、必ずインターフェースを経由する。

### 5. 表示層: React + Plotly.js

**フロントエンド分離の理由：**

- Step 2で精密なGUI操作（ドラッグ範囲選択、点のクリック除外、スライダーのリアルタイム反映）が必要
- 将来的にUIを別の技術スタックに置き換える可能性への対応
- アーキテクチャ設計で表示層の独立性は担保済み

**フレームワーク候補の比較：**

| | エコシステム | グラフライブラリ相性 | バンドルサイズ | UI表現の自由度 |
|---|---|---|---|---|
| **React** | **最大** | **最高** | 中 | **高** |
| Vue | 大 | 高 | 小〜中 | 高 |
| Svelte | 中 | やや薄い | 極小 | 高 |

**Reactの採用理由：**

1. **公式ラッパーの充実** — Plotly.js（react-plotly.js）、Recharts、Nivo等、主要グラフライブラリがReact専用ラッパーを公式提供。メンテナンス頻度・ドキュメント充実度で一段上
2. **コンポーネントモデルとの相性** — 「propsが変わったら再描画」の単方向データフローがStep 2のリアルタイム反映に直結。感度スライダーの値変更→props→グラフ再描画→色分け更新がそのまま実装できる
3. **Step 2に必要なインタラクションが揃っている** — Plotly.jsのBox Select/Lasso Select（範囲選択）、clickイベント（除外点選択）、Reactのフォーム制御（スライダー）を一つのコンポーネントツリーで状態管理できる

### 6. コンテナ構成: 1コンテナ

**1コンテナ vs 複数コンテナの比較：**

| | 1コンテナ | 複数コンテナ（podman-compose） |
|---|---|---|
| 構成のシンプルさ | 高 | 低（コンテナ間通信、ボリューム共有の設定が必要） |
| 再ビルド粒度 | 粗い（全体再ビルド。ただしレイヤーキャッシュで軽減可） | 細かい（影響範囲のみ） |
| プロセス管理 | supervisord等が必要 | 各コンテナ1プロセス |
| ログ | 混在する（プレフィックスで対処可） | コンテナ単位で分離 |
| SQLiteとの相性 | 高（ファイルアクセスが同一コンテナ内で完結） | 低（複数コンテナからの同一ファイルアクセスはトラブルの元） |

**1コンテナの採用理由：**

- SQLiteがファイルベースDBであるため、1コンテナの方が自然でトラブルが少ない
- 現時点の規模で複数コンテナのメリット（個別スケーリング等）を享受する場面がない
- 可用性を重視しないためフェイルオーバー構成も不要
- デメリット（再ビルド粒度、プロセス管理、ログ混在）はいずれも実用上対処可能

**コンテナ内のプロセス構成：**

- FastAPI（取り込みAPI + データ提供API）
- 分析層スケジューラー（定期実行 + 手動トリガー）
- nginx等（フロントエンドの静的ファイル配信）
- supervisordでプロセス管理

**コンテナ内のデータ：**

- Store層: SQLiteファイル
- 結果ストア: SQLiteファイル（Store層とは別ファイル）
- フロントエンド: Reactビルド済み静的ファイル

---

## 技術スタック一覧

| 層 | 技術 |
|----|------|
| Store層 | SQLite |
| 結果ストア | SQLite（別ファイル） |
| 分析層 | Python + scikit-learn + numpy + pandas |
| 取り込み層（API） | Python + FastAPI |
| 表示層 | React + Plotly.js |
| コンテナ | Podman（1コンテナ、supervisord） |
| フロントエンド配信 | nginx |

---

*最終更新: 2026-02-10*
